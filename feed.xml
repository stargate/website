<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="https://stargate.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://stargate.io/" rel="alternate" type="text/html" /><updated>2022-12-22T16:56:10+00:00</updated><id>https://stargate.io/feed.xml</id><title type="html">Stargate</title><subtitle>An open source API framework for data.</subtitle><author><name></name></author><entry><title type="html">Stargate Community Update December 2022</title><link href="https://stargate.io/2022/12/18/year-end-update.html" rel="alternate" type="text/html" title="Stargate Community Update December 2022" /><published>2022-12-18T06:00:00+00:00</published><updated>2022-12-18T06:00:00+00:00</updated><id>https://stargate.io/2022/12/18/year-end-update</id><content type="html" xml:base="https://stargate.io/2022/12/18/year-end-update.html">&lt;p&gt;Hello Stargate community! It’s hard to believe it’s already been two months since the &lt;a href=&quot;https://stargate.io/2022/10/26/stargate-v2-ga.html&quot;&gt;GA release&lt;/a&gt; of Stargate v2! There’s been a lot of activity on the project since that milestone and we wanted to share a few recent highlights as we begin to close out the year:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Dynamo Adapter Prototype&lt;/strong&gt; - since February, the Stargate core team have had the privilege of mentoring a team of students from Carnegie Mellon University pursuing their Master of Computational Data Science degree. After sharing about their work in the Spring 2022 semester on the &lt;a href=&quot;https://stargate.io/2022/05/23/towards-dynamodb-compatibility-for-cassandra.html&quot;&gt;first half of the project&lt;/a&gt;, Boxuan Li, Ziyan Zhang and Xiang Yue have now completed a prototype of a &lt;a href=&quot;https://github.com/stargate/dynamoDB-adapter&quot; rel=&quot;nofollow&quot;&gt;DynamoDB Adapter&lt;/a&gt; for Stargate, which they have generously donated to the Stargate project. You can see a &lt;a href=&quot;https://www.youtube.com/watch?v=7ZUD2J8wGLI&quot;&gt;demo&lt;/a&gt; on YouTube. We’d love to continue work on this prototype with future student groups or other interested community members, as it is an important validation of the v2 architecture.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Helm chart&lt;/strong&gt; - in addition to the Docker compose scripts we provide for simple containerized deployment, we’ve added a &lt;a href=&quot;https://github.com/stargate/stargate/tree/main/helm&quot; rel=&quot;nofollow&quot;&gt;Helm Chart&lt;/a&gt; as a new option for deploying Stargate in Kubernetes alongside an existing Cassandra cluster. You can read about it in &lt;a href=&quot;https://medium.com/building-the-open-data-stack/deploying-stargate-api-using-helm-300dbf11cb5&quot;&gt;this blog&lt;/a&gt;. For a complete distribution of Stargate with Cassandra on Kubernetes, we hope to have &lt;a href=&quot;https://github.com/k8ssandra/k8ssandra-operator/issues/688&quot; rel=&quot;nofollow&quot;&gt;support for Stargate v2&lt;/a&gt; in K8ssandra in the near future.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Inclusive branch naming&lt;/strong&gt; - we have completed the renaming of our default branch to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main&lt;/code&gt;, as announced &lt;a href=&quot;https://stargate.io/2021/12/14/announce-github-naming-change.html&quot;&gt;previously&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Support and deprecation strategy&lt;/strong&gt; - the release of v2 has enabled us to start thinking more strategically about how to support the project going forward. We’ve started GitHub Discussions to get your feedback on our plans to phase out support for &lt;a href=&quot;https://github.com/stargate/stargate/discussions/2242&quot; rel=&quot;nofollow&quot;&gt;Cassandra 3.x&lt;/a&gt;, the &lt;a href=&quot;https://github.com/stargate/stargate/discussions/2242&quot; rel=&quot;nofollow&quot;&gt;REST v1 API&lt;/a&gt;, and the &lt;a href=&quot;https://github.com/stargate/stargate/discussions/2294&quot; rel=&quot;nofollow&quot;&gt;Stargate v1&lt;/a&gt; release series.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In terms of what’s next, there are several exciting areas we’re looking at for the new year:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Sizing guidance&lt;/strong&gt; - we get frequent requests for how to size and scale Stargate deployments in both vertically (number of instances) and horizontally (hardware resources). We are developing more concrete sizing guidance based on performance profiling of several different configurations and workloads.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;New APIs&lt;/strong&gt; - We’ve started planning some new API work based on the v2 architecture and are interested in your inputs and contributions as well, as Mark Stone shared in his &lt;a href=&quot;https://stargate.io/2022/10/30/contributing-stargate.html&quot;&gt;recent blog&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Cassandra Summit 2023&lt;/strong&gt; - we’re looking forward to the first dedicated &lt;a href=&quot;https://events.linuxfoundation.org/cassandra-summit/&quot;&gt;Cassandra conference&lt;/a&gt; in several years in March 2023. In talking with various community members we’re aware of at least 10 Stargate-related submissions to the CFP, so we’re hopeful that the project will be well represented. Registration for the conference is &lt;a href=&quot;https://events.linuxfoundation.org/cassandra-summit/register/&quot;&gt;open&lt;/a&gt; and we hope to see many of you there, whether in-person or virtually.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Thanks to everyone for your support of the community and commitment to the idea that &lt;a href=&quot;https://thenewstack.io/why-databases-need-apis/&quot;&gt;databases need APIs&lt;/a&gt;. We wish you a great holiday season and look forward to collaborating with you in 2023!&lt;/p&gt;</content><author><name></name></author><summary type="html">Hello Stargate community! It’s hard to believe it’s already been two months since the GA release of Stargate v2! There’s been a lot of activity on the project since that milestone and we wanted to share a few recent highlights as we begin to close out the year:</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://stargate.io/assets/images/default-stargate.png" /><media:content medium="image" url="https://stargate.io/assets/images/default-stargate.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Why and How to Contribute to Stargate</title><link href="https://stargate.io/2022/10/30/contributing-stargate.html" rel="alternate" type="text/html" title="Why and How to Contribute to Stargate" /><published>2022-10-30T06:00:00+00:00</published><updated>2022-10-30T06:00:00+00:00</updated><id>https://stargate.io/2022/10/30/contributing-stargate</id><content type="html" xml:base="https://stargate.io/2022/10/30/contributing-stargate.html">&lt;p&gt;As an open source project Stargate, the data gateway for Apache Cassandra, has always been open to outside contribution and participation. With &lt;a href=&quot;https://stargate.io/2022/10/26/stargate-v2-ga.html&quot;&gt;Stargate v2&lt;/a&gt;, we’ve taken practical steps to make it easier to  contribute. We value diverse perspectives on how we should evolve Stargate. With diversity of opinion comes greater innovation. Please help us innovate for the benefit of both Stargate and Cassandra.&lt;/p&gt;

&lt;h2 id=&quot;why-you-should-contribute-to-stargate&quot;&gt;Why You Should Contribute to Stargate&lt;/h2&gt;

&lt;p&gt;All open source projects offer a variety of ways for the open source community to contribute, and Stargate is no different:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Contribute to our documentation with examples or how-tos.&lt;/li&gt;
  &lt;li&gt;Modify the code based one what you want to see in Stargate, and submit a pull request.&lt;/li&gt;
  &lt;li&gt;Install and run Stargate for yourself, and make a feature suggestion.&lt;/li&gt;
  &lt;li&gt;Find and report bugs.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Historically, as an open source project whose development is driven primarily by one company (DataStax), and whose code base has been both complex and monolithic in nature, the bar to becoming a Stargate contributor has been set pretty high.&lt;/p&gt;

&lt;p&gt;Until now, that is. With Stargate v2 we have made the code base more modular, more approachable, and thus easier to contribute to. In fact, we have three specific areas where it would be valuable to the community to receive contributions.&lt;/p&gt;

&lt;h2 id=&quot;extending-grpc-access&quot;&gt;Extending gRPC Access&lt;/h2&gt;

&lt;p&gt;The first opportunity to easily contribute to Stargate predates v2. A year ago we released our gRPC API for Stargate, along with a set of gRPC client libraries, as a means of making CQL calls over gRPC as a transit protocol. We also leverage &lt;a href=&quot;https://github.com/stargate/stargate/tree/master/grpc-proto/proto&quot;&gt;gRPC protobuf&lt;/a&gt; files to create the skeleton of a CQL query engine in whatever language you compile the gRPC library for.&lt;/p&gt;

&lt;p&gt;We launched gRPC with client libraries for &lt;a href=&quot;https://github.com/stargate/stargate-grpc-java-client&quot;&gt;Java&lt;/a&gt;, &lt;a href=&quot;https://github.com/stargate/stargate-grpc-go-client&quot;&gt;Go&lt;/a&gt;, &lt;a href=&quot;https://github.com/stargate/stargate-grpc-node-client&quot;&gt;Node.js&lt;/a&gt;, and &lt;a href=&quot;https://github.com/stargate/stargate-grpc-rust-client&quot;&gt;Rust&lt;/a&gt;. Of note is that neither the Node.js nor the Rust libraries were written by developers on the core Stargate team at DataStax. Equally important, the work was done quickly, in each case a few weeks’ of side project effort.&lt;/p&gt;

&lt;p&gt;This is by design. The intent is not that the core team will write every library that the community might find useful. The intent is to make writing these client libraries so easy that anyone who sees a need could simply write one for themselves.&lt;/p&gt;

&lt;h2 id=&quot;extending-stargate-apis&quot;&gt;Extending Stargate APIs&lt;/h2&gt;

&lt;p&gt;Version 2 of Stargate breaks down the monolith and instead isolates each API as a separate service. We still have Stargate coordinator nodes that talk directly to Cassandra via CQL, and for performance reasons we still have the gRPC API and the CQL API talking directly to these coordinator nodes. Our other APIs talk to a new bridge endpoint in the coordinator via gRPC.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/assets/images/stargate-v2-high-level.png&quot; alt=&quot;Figure 1: Stargate v2 High Level Architecture&quot; /&gt;
  &lt;figcaption style=&quot;text-align: center;&quot;&gt;Figure 1: Stargate v2 High Level Architecture&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Previously, in order to extend Stargate you had to understand quite a bit of the code in order to do much of anything. Now someone wanting to add a new HTTP-based API would only have to learn the bridge API, and learn about gRPC networking. This should provide a much lower barrier to entry for extending Stargate with new APIs.&lt;/p&gt;

&lt;h2 id=&quot;extending-stargate-to-new-data-stores&quot;&gt;Extending Stargate to New Data Stores&lt;/h2&gt;

&lt;p&gt;Right now Stargate only talks to Apache Cassandra as a data store. Given that DataStax is a Cassandra-oriented company, that will always be our focus. Architecturally, though, Stargate could be extended to work with other data stores.&lt;/p&gt;

&lt;p&gt;This would be a matter of learning the Stargate coordinator code as a starting point. We grant that this is a higher barrier to entry than learning the bridge code. Anyone with knowledge of the coordinator code and mastery of the internals of another data store should be able to rewrite the coordinator code to talk to that alternate data store, extending Stargate in a fundamentally new way.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;There is no wrong way to contribute to Stargate. While the core Stargate team have our own ideas and incoming requests from DataStax Astra, we don’t want to be on this journey alone, which is a big part of why we wrote Stargate v2.&lt;/p&gt;

&lt;p&gt;Those of you in the open source Stargate community will have your own views about what’s important, and what should be prioritized. Engage with us, and share your passionately held views. We can disagree, and in constructive disagreement find a better path forward.&lt;/p&gt;

&lt;p&gt;Building knowledge through better documentation; truly the lowest barrier to entry for participation, and maybe the most important:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Test our &lt;a href=&quot;https://stargate.io/docs&quot;&gt;documentation&lt;/a&gt;! Where did we get it wrong, or fall behind current functionality in the Stargate platform?&lt;/li&gt;
  &lt;li&gt;Give us a write-up of your favorite examples. Quality, approachable reference examples are an essential part of a project.&lt;/li&gt;
  &lt;li&gt;Finally figured out something that was initially puzzling? Write a how-to; we love how-tos!&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Extending gRPC:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;We’d like to have a Python library.&lt;/li&gt;
  &lt;li&gt;We’d also like to have a C# library.&lt;/li&gt;
  &lt;li&gt;What would you like to see, or help create?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Extending APIs:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;AWS Dynamo is a great data interface, and it’s specific to AWS. A group of students from Carnegie Mellon University has started work on a &lt;a href=&quot;https://stargate.io/2022/05/23/towards-dynamodb-compatibility-for-cassandra.html&quot;&gt;Dynamo-compatible API&lt;/a&gt; for Stargate that could make this capability available in multiple clouds.&lt;/li&gt;
  &lt;li&gt;What additional APIs would you like to see, or help build?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Extending to new DataStores&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;We’d like to cover more variants of Cassandra than just the three we currently cover (Apache Cassandra 3.x/4.x, DataStax Enterprise, and &lt;a href=&quot;https://astra.datastax.com&quot;&gt;DataStax Astra DB&lt;/a&gt;). AWS Keyspaces, for example, is another Cassandra variant that could benefit from Stargate.&lt;/li&gt;
  &lt;li&gt;What additional data stores would you like to see, or contribute to integrating?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The best way to get involved with these efforts is to jump right into the project GitHub. Create an &lt;a href=&quot;https://github.com/stargate/stargate/issues&quot;&gt;issue&lt;/a&gt;, submit a &lt;a href=&quot;https://github.com/stargate/stargate/pulls&quot;&gt;pull request&lt;/a&gt;, or start a new &lt;a href=&quot;https://github.com/stargate/stargate/discussions&quot;&gt;discussion&lt;/a&gt;. We look forward to collaborating with you!&lt;/p&gt;</content><author><name></name></author><summary type="html">As an open source project Stargate, the data gateway for Apache Cassandra, has always been open to outside contribution and participation. With Stargate v2, we’ve taken practical steps to make it easier to contribute. We value diverse perspectives on how we should evolve Stargate. With diversity of opinion comes greater innovation. Please help us innovate for the benefit of both Stargate and Cassandra.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://stargate.io/assets/images/default-stargate.png" /><media:content medium="image" url="https://stargate.io/assets/images/default-stargate.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Stargate v2 is Generally Available</title><link href="https://stargate.io/2022/10/26/stargate-v2-ga.html" rel="alternate" type="text/html" title="Stargate v2 is Generally Available" /><published>2022-10-26T06:00:00+00:00</published><updated>2022-10-26T06:00:00+00:00</updated><id>https://stargate.io/2022/10/26/stargate-v2-ga</id><content type="html" xml:base="https://stargate.io/2022/10/26/stargate-v2-ga.html">&lt;p&gt;Back in September, we announced the availability of the &lt;a href=&quot;https://stargate.io/2022/09/11/stargate-v2-beta.html&quot;&gt;Stargate v2 Beta release&lt;/a&gt;. After several betas and a release candidate, we’re excited to announce the availability of the general release of Stargate v2!&lt;/p&gt;

&lt;p&gt;As we’ve discussed in &lt;a href=&quot;https://stargate.io/2021/11/02/announcing-stargate-v2.html&quot;&gt;previous posts&lt;/a&gt;, v2 represents an architectural refactoring that allows more flexible deployments and makes it easier to create new APIs.&lt;/p&gt;

&lt;p&gt;The GA release includes the results of community feedback as well as learnings from the DataStax team on integrating Stargate v2 into &lt;a href=&quot;https://astra.datastax.com&quot;&gt;DataStax AstraDB&lt;/a&gt;, which have served to inject a high level of confidence in the quality of this release.&lt;/p&gt;

&lt;h2 id=&quot;quickstart-for-v2&quot;&gt;Quickstart for v2&lt;/h2&gt;

&lt;p&gt;If you want to try out the v2 release, we have everything set to go for you. In the &lt;a href=&quot;https://stargate.io/2022/09/11/stargate-v2-beta.html&quot;&gt;Beta release blog&lt;/a&gt;, we provided instructions on how to quickly deploy Stargate v2 on your desktop using Docker compose, and then use Postman collections to exercise the APIs.&lt;/p&gt;

&lt;p&gt;We also recommend checking out Pieter Humphrey’s &lt;a href=&quot;https://medium.com/building-the-open-data-stack/stargate-brings-apache-cassandra-to-the-postman-api-network-a18d973714b&quot;&gt;blog post&lt;/a&gt; for a more in-depth introduction to these collections and how to use them.&lt;/p&gt;

&lt;h2 id=&quot;migrating-to-v2&quot;&gt;Migrating to v2&lt;/h2&gt;

&lt;p&gt;If you’re currently using Stargate v1 and are ready to upgrade to v2, the process is straightforward. For users that are only using gRPC and CQL APIs, you only need to update your configuration to run the v2 version of the coordinator. Restarting nodes in your backing Cassandra cluster is not required, and you can use a rolling restart approach to update coordinator nodes and your clients for a zero-downtime update.&lt;/p&gt;

&lt;p&gt;In addition, if you’re using Stargate HTTP APIs such as REST, GraphQL or Docs API, you will need to run instances of each API service you need. These APIs are packaged as separate containers from the v2 coordinator node.&lt;/p&gt;

&lt;p&gt;We recommend running at least two instances of each API service you use to ensure high availability, as shown in the figure. The good news is that this will not consume a large amount of additional resources, since all three API services use the &lt;a href=&quot;https://quarkus.io/&quot;&gt;Quarkus framework&lt;/a&gt; to create lightweight container images based on JDK 17. For more detail see Ivan Senic’s recent interview on the &lt;a href=&quot;https://www.youtube.com/watch?v=nBX-J4LgEog&quot;&gt;Quarkus Insights podcast&lt;/a&gt;.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/assets/images/stargate-v2-high-level.png&quot; alt=&quot;Figure 1: Stargate v2 High Level Architecture&quot; /&gt;
  &lt;figcaption style=&quot;text-align: center;&quot;&gt;Figure 1: Stargate v2 High Level Architecture&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Images for the coordinator and API services are available on &lt;a href=&quot;https://hub.docker.com/u/stargateio&quot;&gt;Docker Hub&lt;/a&gt;, and we’ve also made sample Docker compose configurations available in the Stargate GitHub repository.&lt;/p&gt;

&lt;p&gt;In order to complete a migration of your HTTP clients to the new APIs, you’ll want to repoint your clients to the new API endpoints. If you’ve deployed a load balancer in front of the Stargate HTTP APIs in v1 deployments, this will be a trivial change requiring no downtime.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;All of the default port numbers are the same, with the exception of the Documents API.&lt;/li&gt;
  &lt;li&gt;Paths for APIs move to the new services, including developer tools like Swagger and GraphQL playground&lt;/li&gt;
  &lt;li&gt;The REST v1 API remains on the coordinator node, we’re actively discussing how long to maintain this original version of the REST API, but for the moment it is not supported by the v2 REST API service.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For more details on ports and paths for v2, see the table below.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;API&lt;/th&gt;
      &lt;th&gt;v1 URLs&lt;/th&gt;
      &lt;th&gt;v2 URLs&lt;/th&gt;
      &lt;th&gt;Note&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Metrics&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;http://&amp;lt;coordinator&amp;gt;:8084/metrics&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;http://&amp;lt;coordinator&amp;gt;:8084/metrics&lt;/code&gt;&lt;br /&gt;&lt;code&gt;http://&amp;lt;restapi&amp;gt;:8082/metrics&lt;/code&gt;&lt;br /&gt;&lt;code&gt;http://&amp;lt;docsapi&amp;gt;:8180/metrics&lt;/code&gt;&lt;br /&gt;&lt;code&gt;http://&amp;lt;graphqlapi&amp;gt;:8080/metrics&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;New metrics endpoints for API services, coordinator unchanged&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Health&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;http://&amp;lt;coordinator&amp;gt;:8084/checker/liveness&lt;/code&gt;&lt;br /&gt;&lt;code&gt;http://&amp;lt;coordinator&amp;gt;:8084/checker/readiness&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;http://&amp;lt;coordinator&amp;gt;:8084/checker/liveness&lt;/code&gt;&lt;br /&gt;&lt;code&gt;http://&amp;lt;coordinator&amp;gt;:8084/checker/readiness&lt;/code&gt;&lt;br /&gt;&lt;code&gt;http://&amp;lt;restapi&amp;gt;:8082/stargate/health&lt;/code&gt;&lt;br /&gt;&lt;code&gt;http://&amp;lt;graphqlapi&amp;gt;:8080/stargate/health&lt;/code&gt;&lt;br /&gt;&lt;code&gt;http://&amp;lt;docsapi&amp;gt;:8180/stargate/health&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;New health endpoints for API services, coordinator unchanged&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Auth API&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;http://&amp;lt;coordinator&amp;gt;:8081/v1/auth/token/generate&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;http://&amp;lt;coordinator&amp;gt;:8081/v1/auth/token/generate&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;No change&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;gRPC&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;http://&amp;lt;coordinator&amp;gt;:8090&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;http://&amp;lt;coordinator&amp;gt;:8090&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;No change&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;REST v1&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;http://&amp;lt;coordinator&amp;gt;:8082/v1/keyspaces&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;http://&amp;lt;coordinator&amp;gt;:8082/v1/keyspaces&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;No change, legacy REST v1 remains on coordinator&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;REST v2&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;http://&amp;lt;coordinator&amp;gt;:8082/v2/keyspaces&lt;/code&gt;&lt;br /&gt;&lt;code&gt;http://&amp;lt;coordinator&amp;gt;:8082/v2/schemas/keyspaces&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;http://&amp;lt;restapi&amp;gt;:8082/v2/keyspaces&lt;/code&gt;&lt;br /&gt;&lt;code&gt;http://&amp;lt;restapi&amp;gt;:8082/v2/schemas/keyspaces&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;REST v2 APIs move to new service&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Docs API&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;http://&amp;lt;coordinator&amp;gt;:8082/v2/namespaces&lt;/code&gt;&lt;br /&gt;&lt;code&gt;http://&amp;lt;coordinator&amp;gt;:8082/v2/schemas/namespaces&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;http://&amp;lt;docsapi&amp;gt;:8180/v2/namespaces&lt;/code&gt;&lt;br /&gt;&lt;code&gt;http://&amp;lt;docsapi&amp;gt;:8180/v2/schemas/namespaces&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Docs APIs move to new service, port number changed to 8180&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Swagger&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;http://&amp;lt;coordinator&amp;gt;:8082/swagger-ui&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;http://&amp;lt;coordinator&amp;gt;:8082/swagger-ui&lt;/code&gt;&lt;br /&gt;&lt;code&gt;http://&amp;lt;restapi&amp;gt;:8082/swagger-ui&lt;/code&gt;&lt;br /&gt;&lt;code&gt;http://&amp;lt;docsapi&amp;gt;:8180/swagger-ui&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;REST v1 swagger remains on coordinator, REST v2 and Docs API on new services&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;GraphQL&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;http://&amp;lt;coordinator&amp;gt;:8080/graphql-schema&lt;/code&gt;&lt;br /&gt;&lt;code&gt;http://&amp;lt;coordinator&amp;gt;:8080/graphql-admin&lt;/code&gt;&lt;br /&gt;&lt;code&gt;http://&amp;lt;coordinator&amp;gt;:8080/graphql&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;http://&amp;lt;graphqlapi&amp;gt;:8080/graphql-schema&lt;/code&gt;&lt;br /&gt;&lt;code&gt;http://&amp;lt;graphqlapi&amp;gt;:8080/graphql-admin&lt;/code&gt;&lt;br /&gt;&lt;code&gt;http://&amp;lt;graphqlapi&amp;gt;:8080/graphql&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;GraphQL APIs move to new service&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Playground&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;http://&amp;lt;coordinator&amp;gt;:8080/playground&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;http://&amp;lt;graphqlapi&amp;gt;:8080/playground&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;GraphQL Playground moves to new service&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Bridge&lt;/td&gt;
      &lt;td&gt;N/A&lt;/td&gt;
      &lt;td&gt;&lt;code&gt;http://&amp;lt;coordinator&amp;gt;:8091&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;New in v2 for building API services&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Regardless of your particular deployment, no application code changes should be required (beyond any configuration updates required to point to new endpoints), as all Stargate v2 API implementations are backward compatible with v1 implementations.&lt;/p&gt;

&lt;p&gt;Some users may be deploying Stargate as part of a K8ssandra cluster. We’re &lt;a href=&quot;https://github.com/k8ssandra/k8ssandra-operator/issues/688&quot;&gt;actively collaborating&lt;/a&gt; with the K8ssandra team on extending the K8ssandra operator to be able to deploy and scale Stargate v2, including both the coordinator node and the new API services.&lt;/p&gt;

&lt;h2 id=&quot;what-comes-after-v2&quot;&gt;What Comes After v2?&lt;/h2&gt;

&lt;p&gt;As we move forward, we’ll continue to maintain the support of existing APIs and work toward modernization of the coordinator node including JDK updates, Quarkus adoption, and removal of OSGI from the coordinator.&lt;/p&gt;

&lt;p&gt;We’re also excited for the possibility of developing new APIs. The &lt;a href=&quot;https://stargate.io/2022/05/23/towards-dynamodb-compatibility-for-cassandra.html&quot;&gt;Dynamo API prototype&lt;/a&gt; developed as a masters project by a team of students from Carnegie Mellon University has served as a valuable proof point of the extensibility of the v2 architecture.&lt;/p&gt;

&lt;p&gt;In our next blog we’ll talk more about how you can contribute to the Stargate project, whether by creating new examples, adding APIs, or extending the coordinator node.&lt;/p&gt;</content><author><name></name></author><summary type="html">Back in September, we announced the availability of the Stargate v2 Beta release. After several betas and a release candidate, we’re excited to announce the availability of the general release of Stargate v2!</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://stargate.io/assets/images/default-stargate.png" /><media:content medium="image" url="https://stargate.io/assets/images/default-stargate.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Stargate v2 Beta: Open for extension</title><link href="https://stargate.io/2022/09/11/stargate-v2-beta.html" rel="alternate" type="text/html" title="Stargate v2 Beta: Open for extension" /><published>2022-09-11T06:00:00+00:00</published><updated>2022-09-11T06:00:00+00:00</updated><id>https://stargate.io/2022/09/11/stargate-v2-beta</id><content type="html" xml:base="https://stargate.io/2022/09/11/stargate-v2-beta.html">&lt;p&gt;Last Friday, we released the first &lt;a href=&quot;https://github.com/stargate/stargate/releases/tag/v2.0.0-BETA-1&quot;&gt;Beta&lt;/a&gt; for Stargate v2. In this post we’ll look at why this is a major milestone for the project and how you can try out this new release yourself.&lt;/p&gt;

&lt;h2 id=&quot;what-is-stargate-v2&quot;&gt;What is Stargate v2?&lt;/h2&gt;

&lt;p&gt;To answer this question, let’s start with a quick refresher on the Stargate project. We like to refer to Stargate as a “data API gateway” (or data gateway for short) built on top of Apache Cassandra.&lt;/p&gt;

&lt;p&gt;In a technology world that is increasingly dominated by cloud data services rather than databases, application developers are likely to think in terms of data abstractions like JSON rather than an idiom unique to a particular database. An API gateway is therefore an ideal way to meet developers where they are, allowing them to work in frameworks and structures familiar to them without having to know all the particulars of the underlying database. Stargate is designed to meet this need – backed by the power of Cassandra, and presenting REST, Document, and GraphQL as developer friendly APIs. We’ve also added a set of gRPC libraries for doing CQL over gRPC as an easier, lightweight, and more cloud friendly alternative to native drivers for CQL.&lt;/p&gt;

&lt;p&gt;Stargate v2 represents a significant architectural update for our data API gateway, designed to address several opportunities for improvement we identified in working with the original architecture. In particular:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Monolith to modular. The original Stargate codebase is too tightly coupled to the persistence engine, making it hard to develop anything without knowing everything. Going forward, we’re factoring out the REST, GraphQL and Document APIs as independent services. Enhancing a particular API service, or adding an entirely new API service, will be much easier, while CQL and gRPC APIs remain in the coordinator node for optimal performance.&lt;/li&gt;
  &lt;li&gt;Cloud friendly. Being more service-oriented is of course also more cloud friendly. We’ve created a new “bridge” gRPC API to the coordinator node that makes it easy to create additional API services. Supplying a HTTP-based API allows developers to extend the architecture more quickly compared to traditional the CQL binary protocol and drivers. We’re also moving away from OSGi as our containerization standard, and instead making each service deployable as its own Kubernetes pod. Kubernetes is the de facto standard for cloud deployments, and we’re happy to align with that. This will also improve compatibility with the cloud native version of Cassandra, namely &lt;a href=&quot;https://k8ssandra.io/&quot;&gt;K8ssandra&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;Operator friendly. By leveraging Kubernetes, we can make each service independently deployable and scalable. This will give operators a lot more control over how they manage and scale Stargate.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;What hasn’t changed is our commitment to backward compatibility for all API endpoints. Additionally, Stargate v2 continues to support multiple Cassandra backends including Cassandra 3.11, Cassandra 4.0, and DataStax Enterprise 6.8. Stargate is also deployed as part of DataStax AstraDB, which provides important feedback on usage of Stargate at scale. To learn more about the Stargate v2 effort, check out our other blogs &lt;a href=&quot;https://stargate.io/2021/11/02/announcing-stargate-v2.html&quot;&gt;announcing the project&lt;/a&gt; and discussing the &lt;a href=&quot;https://stargate.io/2021/11/02/introducing-the-design-for-stargate-v2.html&quot;&gt;design approach&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;why-its-time-to-release-a-beta&quot;&gt;Why it’s time to release a Beta&lt;/h2&gt;

&lt;p&gt;In our last update on Stargate v2, we &lt;a href=&quot;https://stargate.io/2022/01/06/reaching-the-first-milestone.html&quot;&gt;shared the progress&lt;/a&gt; on factoring the REST API out of the coordinator node as a separate microservice. Since that time we have created a new “Bridge” gRPC API distinct from the publicly available gRPC API and factored the GraphQL and Document API endpoints out of the coordinator into their own separate microservices. All three API services use the &lt;a href=&quot;https://quarkus.io/&quot;&gt;Quarkus framework&lt;/a&gt;, which enables them to be very lightweight and leverage an up-to-date Java version - JDK 17.&lt;/p&gt;

&lt;p&gt;We are now getting close to a Release Candidate, and have a worthy Beta. This enables the open source community to start trying out Stargate v2 at near production quality in a couple of key areas:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Performance and scalability - we want to give you the opportunity to validate that performance continues to meet your expectations. It will also allow you to explore the new deployment and scaling possibilities of a specific API , deploying only the API services you actually need.&lt;/li&gt;
  &lt;li&gt;Extensibility - a key goal of Stargate v2 is the idea that the community should be able to add new API services &lt;a href=&quot;https://stargate.io/2022/05/23/towards-dynamodb-compatibility-for-cassandra.html&quot;&gt;more quickly and easily&lt;/a&gt;. The Bridge API exposed by the Coordinator services is really all that’s needed to add a new API service, and the source code for the REST, GraphQL, and Document API services provide instructive example code of what a finished API service should look like.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The Beta designation is our way of signaling that these facets of v2 are ready for full exploration and testing by the open source community.&lt;/p&gt;

&lt;h2 id=&quot;how-to-run-stargate-v2&quot;&gt;How to run Stargate v2&lt;/h2&gt;

&lt;p&gt;Now that we have a Beta release, why not give it a try? To make it easier to experiment with the release, we’ve built Docker images and provided Docker Compose scripts in order to spin up Stargate with a backing Cassandra or DSE cluster. The Docker images are available on our &lt;a href=&quot;https://hub.docker.com/u/stargateio&quot;&gt;Docker Hub&lt;/a&gt; page, but the easiest way to run is to clone the Stargate repo and use the scripts we’ve provided:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git clone https://github.com/stargate/stargate.git
cd stargate
git checkout v2.0.0
cd docker-compose
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;From here, you’ll see three subdirectories: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cassandra-3.11&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cassandra-4.0&lt;/code&gt;, and	&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dse-6.8&lt;/code&gt;. Depending on which Cassandra backend you wish to use, there are scripts available to start Stargate in Docker. Let’s look at Cassandra 4.0 as an example:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd cassandra-4.0
./start_cass_40_dev_mode.sh -t 2.0.0-BETA-1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-t&lt;/code&gt; option defines which version to use, in this case &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2.0.0-BETA-1&lt;/code&gt;. We’ve provided these scripts that wrap Docker Compose to make it easier to impose the desired startup sequence. The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;start_cass_40_dev_mode.sh&lt;/code&gt; script provides a simple configuration that starts a single instance of the REST and GraphQL APIs and a single instance of the Stargate coordinator in “developer mode”, meaning that the coordinator is running a full Cassandra 4.0 node. Developer mode is a feature that many Stargate users don’t know about but it’s a great option for simple testing. If you’d like to run with a 3-node Cassandra cluster instead, you can use the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;start_cass_40.sh&lt;/code&gt; script, again using the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-t&lt;/code&gt; option to specify the desired release.&lt;/p&gt;

&lt;p&gt;Once you have a cluster running, it’s a simple matter to generate some test queries against your running instance. The easiest way to do this is to use our recently updated Postman collections. There are three collections available: REST, GraphQL and Docs API. Once you have Postman installed, you can load the collections from the &lt;a href=&quot;https://www.postman.com/datastax/workspace/datastax-astra-db-stargate/overview&quot;&gt;DataStax workspace&lt;/a&gt; on the Postman website. See the Stargate &lt;a href=&quot;https://stargate.io/docs/latest/develop/tooling.html&quot;&gt;documentation&lt;/a&gt; for more information.&lt;/p&gt;

&lt;p&gt;For example, let’s try running the REST collection against our local Stargate v2 cluster. After loading the collections, make sure to select the “Stargate OSS API Environment” from the pulldown at the upper right (1). This configures settings that will cause Postman to talk to endpoints on your local computer using the default port number. Then select the “Stargate-OSS-Astra-REST-API” collection from the list on the left (2) and run the collection (3).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/stargate-v2-postman.png&quot; alt=&quot;postman&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Now you can sit back and watch as Postman uses Stargate’s authentication API to generate a token and use that token to securely invoke operations against your local copy of the Stargate REST API. Try out the other collections as well and let us know what you think.&lt;/p&gt;

&lt;h2 id=&quot;we-want-your-feedback&quot;&gt;We want your feedback&lt;/h2&gt;

&lt;p&gt;What’s next? In the coming weeks we’ll continue to generate additional Beta releases based on your feedback. We will especially want feedback when we’ve reached what we consider to be a Release Candidate.&lt;/p&gt;

&lt;p&gt;You can provide feedback through whatever channel is easiest for you:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;We do our work out in the open, so &lt;a href=&quot;https://github.com/stargate/stargate&quot;&gt;Github&lt;/a&gt; is a great place to provide feedback, and we use &lt;a href=&quot;https://github.com/stargate/stargate/discussions&quot;&gt;Github Discussions&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;We also have a &lt;a href=&quot;https://discord.gg/33mKDHHFUE&quot;&gt;Discord server&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;Or find us on &lt;a href=&quot;https://twitter.com/stargateio&quot;&gt;Twitter&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;Or &lt;a href=&quot;https://www.linkedin.com/groups/9091327/?lipi=urn%3Ali%3Apage%3Ad_flagship3_groups_index%3BiWk36RDvQXmdJSCjsT5YlQ%3D%3D&quot;&gt;LinkedIn&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><summary type="html">Last Friday, we released the first Beta for Stargate v2. In this post we’ll look at why this is a major milestone for the project and how you can try out this new release yourself.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://stargate.io/assets/images/default-stargate.png" /><media:content medium="image" url="https://stargate.io/assets/images/default-stargate.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Stargate: Towards DynamoDB Compatibility for Cassandra (Part 2)</title><link href="https://stargate.io/2022/05/31/towards-dynamodb-compatibility-for-cassandra-part-2.html" rel="alternate" type="text/html" title="Stargate: Towards DynamoDB Compatibility for Cassandra (Part 2)" /><published>2022-05-31T06:00:00+00:00</published><updated>2022-05-31T06:00:00+00:00</updated><id>https://stargate.io/2022/05/31/towards-dynamodb-compatibility-for-cassandra-part-2</id><content type="html" xml:base="https://stargate.io/2022/05/31/towards-dynamodb-compatibility-for-cassandra-part-2.html">&lt;p&gt;In my &lt;a href=&quot;/2022/05/23/towards-dynamodb-compatibility-for-cassandra.html&quot;&gt;previous blog post&lt;/a&gt;, I introduced the Dynamo API Service, which is our project to make Apache Cassandra&lt;sup&gt;Ⓡ&lt;/sup&gt; compatible with Amazon DynamoDB by building a middleware. In this blog post, I will share a few interesting challenges we encountered and how we tackled them.&lt;/p&gt;

&lt;h2 id=&quot;how-to-authenticate&quot;&gt;How to authenticate?&lt;/h2&gt;

&lt;p&gt;This is the first problem we encountered. InDynamoDB (and many other AWS products), there are multiple ways to authenticate, among which a common way is to set &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AWS_ACCESS_KEY_ID&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AWS_SECRET_ACCESS_KEY&lt;/code&gt; environmental variables.&lt;/p&gt;

&lt;p&gt;Usually, you don’t need to worry about authentication after you have your Dynamo DB credentials set up. Stargate, on the other hand, requires you to provide a &lt;a href=&quot;https://stargate.io/docs/stargate/1.0/developers-guide/authnz.html&quot;&gt;token&lt;/a&gt; in every request you make. We could let users follow the authentication guide and fetch their token either manually or programmatically, but the problem was how to make the DynamoDB client aware of this token and carry the token every time it makes an HTTP request. Of course, we could rewrite the DynamoDB client by ourselves, but we would like to avoid that if possible so that users don’t need to change their client library.&lt;/p&gt;

&lt;p&gt;Luckily, we found a trick to tackle this problem. We found out that the DynamoDB client always puts an authorization header that contains an unencrypted &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AWS_ACCESS_KEY_ID&lt;/code&gt; in every HTTP request it makes. This makes sense because a DynamoDB client has to use the HTTP protocol to authenticate itself with the DynamoDB server. Now, in the Dynamo API Service for Stargate, we can easily read the token from this &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AWS_ACCESS_KEY_ID&lt;/code&gt; field. Problem solved. All the user needs to do is to put the Stargate token into their &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AWS_ACCESS_KEY_ID&lt;/code&gt; environment variable, and then they don’t need to worry about authentication while making requests!&lt;/p&gt;

&lt;h2 id=&quot;the-discrepancy-in-data-types&quot;&gt;The discrepancy in data types&lt;/h2&gt;

&lt;p&gt;Cassandra and DynamoDB have similar data models but they are not exactly the same. There is one-to-one mapping for basic types but not for the map, list, and set data types in DynamoDB. In DynamoDB, maps, lists, and sets can be deeply nested, meaning that you can have a list of maps of sets or even more complicated data structures. For example, you could insert an item whose &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;goods&lt;/code&gt; attribute contains:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[
 {
   &quot;name&quot;: &quot;apple&quot;,
   &quot;price&quot;: 4,
   &quot;images&quot;: [
     &quot;apple1.jpg&quot;,
     &quot;apple2.jpg&quot;
   ]
 },
 {
   &quot;name&quot;: &quot;orange&quot;,
   &quot;price&quot;: 1.45,
   &quot;images&quot;: &quot;orange.jpg&quot;
 }
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;As we can see, the above data structure is a list of maps. Furthermore, the first map in the list contains &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;images&lt;/code&gt; as a list, while the second map in the list contains &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;images&lt;/code&gt; as a string. This heterogeneity might not be common in the real world but it is undoubtedly allowed as DynamoDB is schemaless. Cassandra, despite its support for nested collections, enforces a schema. For example, if you create a column &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;goods&lt;/code&gt; with:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;goods list&amp;lt;frozen&amp;lt;map&amp;lt;text,text&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Then everything in the inner map must be of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;text&lt;/code&gt; datatype. The Cassandra native support fails this use case.&lt;/p&gt;

&lt;p&gt;We don’t really know how nested collections are stored in DynamoDB (recall it’s not open-sourced!). But one (good) thing we know is that you can only create indices for top-level attributes with basic data types. In the previous example, you cannot index the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;name&lt;/code&gt; field because it’s a nested attribute under &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;goods&lt;/code&gt; which is a top-level attribute. What does this mean for us? This means we can treat the whole nested collection as a BLOB (binary format) without sacrificing the ability to index.&lt;/p&gt;

&lt;p&gt;In all, what we do is quite simple: whenever the user writes a collection data entry, we serialize it into a sequence of bytes and store it in Cassandra. Whenever the user needs to read it, we deserialize the collection from the sequence of bytes stored in Cassandra. And it works just fine! Right now we are using the &lt;a href=&quot;https://github.com/EsotericSoftware/kryo&quot;&gt;Kryo&lt;/a&gt; library for serialization and deserialization, but we might write our own methods for better performance in the future.&lt;/p&gt;

&lt;h2 id=&quot;parser-is-all-you-need&quot;&gt;Parser is all you need&lt;/h2&gt;

&lt;p&gt;If you are building a database, then you almost certainly need to write parsers to parse the queries. DynamoDB, at the first glance, seemed to be an exception because it uses JSON as a request payload — there are so many JSON libraries that can help us with the parsing (deserialization). This seems to suggest we don’t need to worry about writing parsers. Unfortunately, this is not actually the case. DynamoDB queries have fields like &lt;a href=&quot;https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_Query.html#DDB-Query-request-FilterExpression&quot;&gt;&lt;code&gt;FilterExpression&lt;/code&gt;&lt;/a&gt; that allow users to define certain conditions in plain text format. For example, in a query, you can have a filter expression like the following:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(Debt = :debt OR Deposit &amp;lt;&amp;gt; :deposit) AND Sex = :s
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;In this example, the results are filtered out if they don’t satisfy the above expression. This &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FilterExpression&lt;/code&gt; supports different comparison operators and can be nested. You might think about using a regular expression to match the above text, but it is not feasible because &lt;a href=&quot;https://stackoverflow.com/questions/133601/can-regular-expressions-be-used-to-match-nested-patterns&quot;&gt;REGEX generally cannot handle nested expressions&lt;/a&gt;. We actually tried writing regular expressions for simpler cases, but the code quickly turned obscure and we had to give up.&lt;/p&gt;

&lt;p&gt;This is where &lt;a href=&quot;https://www.antlr.org/&quot;&gt;ANTLR&lt;/a&gt; comes into play. ANTLR is a popular and powerful parser generator. By simply defining grammars, ANTLR helps us generate Java code that can parse the expressions into abstract parse trees. We then write code that visits the abstract parse tree and evaluates the expression. With the help of ANTLR, we keep our code concise and easy to maintain. It might be a bit challenging at the beginning to write clean grammar if you are not familiar with compiler knowledge, but it pays off!&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;This concludes our journey toward completion of our capstone project for our Spring semester in the &lt;a href=&quot;https://mcds.cs.cmu.edu/&quot;&gt;Master of Computational Data Science&lt;/a&gt; (MCDS) program at Carnegie Mellon University (CMU). I would like to thank DataStax for the help and guidance throughout this journey. We will continue working on the project in the Fall semester to complete the rest of the APIs and do a thorough performance benchmark. Our hope is to deliver a complete product in the end!&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Special thanks to all the members of the Stargate community who supported this effort including Prabhat Jha, Sebastian Estevez, Tatu Saloranta, and Jeff Carpenter.&lt;/em&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">In my previous blog post, I introduced the Dynamo API Service, which is our project to make Apache CassandraⓇ compatible with Amazon DynamoDB by building a middleware. In this blog post, I will share a few interesting challenges we encountered and how we tackled them.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://stargate.io/assets/images/default-stargate.png" /><media:content medium="image" url="https://stargate.io/assets/images/default-stargate.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Stargate: Towards DynamoDB Compatibility for Cassandra (Part 1)</title><link href="https://stargate.io/2022/05/23/towards-dynamodb-compatibility-for-cassandra.html" rel="alternate" type="text/html" title="Stargate: Towards DynamoDB Compatibility for Cassandra (Part 1)" /><published>2022-05-23T06:00:00+00:00</published><updated>2022-05-23T06:00:00+00:00</updated><id>https://stargate.io/2022/05/23/towards-dynamodb-compatibility-for-cassandra</id><content type="html" xml:base="https://stargate.io/2022/05/23/towards-dynamodb-compatibility-for-cassandra.html">&lt;p&gt;To fulfill my capstone project requirement for the Carnegie Mellon University (CMU) &lt;a href=&quot;https://mcds.cs.cmu.edu/&quot;&gt;Master of Computational Data Science&lt;/a&gt; (MCDS) program, I and two of my classmates, Ziyan Zhang and Xiang Yue, collaborated with &lt;a href=&quot;https://datastax.com/&quot;&gt;DataStax&lt;/a&gt; to develop a new module in the &lt;a href=&quot;http://stargate.io/&quot;&gt;Stargate&lt;/a&gt; system to bring Amazon &lt;a href=&quot;https://aws.amazon.com/dynamodb/&quot;&gt;DynamoDB&lt;/a&gt; compatibility to &lt;a href=&quot;https://cassandra.apache.org/_/index.html&quot;&gt;Apache Cassandra&lt;/a&gt;.&lt;sup&gt;Ⓡ&lt;/sup&gt; I will introduce our journey in two blog posts. Here in Part 1, I will provide some background on the project and describe the overall design of our system. In &lt;a href=&quot;/2022/05/31/towards-dynamodb-compatibility-for-cassandra-part-2.html&quot;&gt;Part 2&lt;/a&gt;, I will discuss some interesting challenges we encountered and how we solved them.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/towards-dynamodb-compatibility-for-cassandra/stargate-dynamodb-compatibility.png&quot; alt=&quot;DynamoDB Compatibility for Cassandra&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;cassandra-vs-dynamodb&quot;&gt;Cassandra vs. DynamoDB&lt;/h2&gt;

&lt;p&gt;Cassandra and DynamoDB are two popular NoSQL databases inspired by Google’s &lt;a href=&quot;https://static.googleusercontent.com/media/research.google.com/en//archive/bigtable-osdi06.pdf&quot;&gt;BigTable&lt;/a&gt; and Amazon’s &lt;a href=&quot;https://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf&quot;&gt;Dynamo&lt;/a&gt; papers. They have many similarities but I think it is more useful to look at some of their biggest differences:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Cassandra is completely free, while DynamoDB is commercial. As a free product, Cassandra can be deployed either on-premise or in the cloud (private, public, or hybrid). For enterprise users, companies like DataStax have cloud offerings and enterprise support for Cassandra. In contrast, despite having a free-tier service, DynamoDB is a commercial and proprietary product, meaning that you have a vendor lock-in problem once you decide to use it. That is, you can only use DynamoDB in AWS but not in your private cloud or any other public cloud. You don’t have much choice if you begin to feel unsatisfied with the pricing or service because the migration cost would be too high.&lt;/li&gt;
  &lt;li&gt;Apache Cassandra is open-source, while Amazon DynamoDB is closed-source. The advantages of open-source products have been widely discussed so I’ll save you some time here. From my personal experience, the biggest advantage of open-source is the ability to make tailor-made changes, and the biggest disadvantage of closed-source is the black-box nature of system behavior — there are always things that are not documented.&lt;/li&gt;
  &lt;li&gt;Cassandra enforces schema while DynamoDB is schemaless. Schemaless might be convenient and flexible for developers, but developers often still need to have some sort of schema on the application side for software engineering reasons.&lt;/li&gt;
  &lt;li&gt;Both databases have their own query languages. Cassandra uses &lt;a href=&quot;https://cassandra.apache.org/doc/latest/cassandra/cql/&quot;&gt;Cassandra Query Language&lt;/a&gt; (CQL), which is a variant of SQL, while DynamoDB (low-level API) uses JSON as a request payload.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;There are many more differences, but the first two illustrate why it might be a good idea to use Cassandra instead of DynamoDB, and the last two point to the potential difficulties in switching to Cassandra if you decide to use DynamoDB and later regret that choice. For users that are already using DynamoDB or already have expertise in using DynamoDB, switching from DynamoDB to Cassandra might be too costly.&lt;/p&gt;

&lt;h2 id=&quot;how-stargate-provides-dynamodb-compatibility&quot;&gt;How Stargate provides DynamoDB compatibility&lt;/h2&gt;

&lt;p&gt;It is difficult for users that are already using and/or are familiar with DynamoDB to switch to Cassandra, so why don’t we make Cassandra compatible with DynamoDB? Wouldn’t it be nice for users to be able to switch from DynamoDB to Cassandra without having to change a single line of their existing codebase if they want to? Bingo! That’s what our project is for. Basically, we leverage a third framework called “Stargate” to build a middleware for Cassandra that is compatible with DynamoDB.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://stargate.io/&quot;&gt;Stargate&lt;/a&gt; is an open source data gateway that sits between your app and your databases.&lt;/p&gt;

&lt;p&gt;Stargate is an open-source middleware that sits on top of a database, e.g. Apache Cassandra. It abstracts Cassandra-specific concepts entirely from app developers and supports different API options, removing barriers of entry for new software developers. Right now, Stargate supports &lt;a href=&quot;https://stargate.io/docs/stargate/1.0/quickstart/quick_start-rest.html&quot;&gt;REST API&lt;/a&gt;, &lt;a href=&quot;https://stargate.io/docs/stargate/1.0/quickstart/quick_start-document.html&quot;&gt;Document API&lt;/a&gt;, &lt;a href=&quot;https://stargate.io/docs/stargate/1.0/developers-guide/gRPC.html&quot;&gt;gRPC API&lt;/a&gt;, and &lt;a href=&quot;https://stargate.io/docs/stargate/1.0/quickstart/quick_start-graphql.html&quot;&gt;GraphQL API&lt;/a&gt;. These different API options are pluggable and can be installed when needed.&lt;/p&gt;

&lt;h2 id=&quot;stargate-architecture&quot;&gt;Stargate Architecture&lt;/h2&gt;

&lt;p&gt;The figure below shows the Stargate (v2) architecture. As described in &lt;a href=&quot;https://stargate.io/2021/11/02/introducing-the-design-for-stargate-v2.html&quot;&gt;this&lt;/a&gt; blog post, Stargate (v2) is highly modular. There are already many services that provide different kinds of APIs. Our goal was to create a new service that provides a DynamoDB API. We wanted this API to be able to understand DynamoDB queries and transform them into Cassandra queries and for users to be able to continue using their existing DynamoDB client code to interact seamlessly with Cassandra.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/towards-dynamodb-compatibility-for-cassandra/stargate-v2-dynamodb.png&quot; alt=&quot;DynamoDB API Service in Stargate V2&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;what-does-a-query-workflow-look-like&quot;&gt;What does a query workflow look like&lt;/h2&gt;

&lt;p&gt;We didn’t want users to have to change a single line of code when switching to Cassandra. But wait a minute…how is that ever possible given Cassandra and DynamoDB have different client libraries? The answer is simple: DynamoDB clients talk to DynamoDB servers in HTTP protocol.&lt;/p&gt;

&lt;p&gt;By implementing a web service on top of Cassandra that behaves in the same way as the DynamoDB server, DynamoDB clients could continue to work without knowing it is actually talking to Cassandra. We implemented such a service as a new module in Stargate - the Dynamo API Service. A typical workflow is shown in the following diagram.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/towards-dynamodb-compatibility-for-cassandra/stargate-dynamodb-query.png&quot; alt=&quot;Sequence Diagram for PutItem API&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;sequence-diagram-for-putitem-api&quot;&gt;Sequence diagram for PutItem API&lt;/h2&gt;

&lt;p&gt;The sequence diagram above shows the workflow for DynamoDB &lt;a href=&quot;https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_PutItem.html&quot;&gt;PutItem API&lt;/a&gt;. Let’s ignore the first component &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AuthResource&lt;/code&gt; for now — all we need to know is that it helps with authentication. By using the DynamoDB client to put an item into the database, the client would send an HTTP request to the configured DynamoDB server endpoint. To use our system, users just need to change their endpoint from AWS to our service. It’s just one line of configuration change! Then everything is handled by our service and Cassandra.&lt;/p&gt;

&lt;p&gt;Let’s get back to the sequence diagram. After receiving an HTTP request, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DynamoResource&lt;/code&gt;, our REST API controller, will recognize the type of request, deserialize the parameters, and then dispatch them to an appropriate Proxy class, in this case, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ItemProxy&lt;/code&gt;. The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ItemProxy&lt;/code&gt; component takes the main responsibility of handling the request. Specifically, it needs to parse the request and transform it into a Stargate intermediate representation. You may ask, why an intermediate representation and not a Cassandra query directly? As we said earlier, Stargate is a middleware that sits on top of your database. Although the database we are using is Cassandra, it could be any other database as long as Stargate supports it.&lt;/p&gt;

&lt;p&gt;By transforming DynamoDB request into Stargate intermediate representation, we leverage the Cassandra adapter that is already implemented by Stargate. After transforming the request to Stargate intermediate representation, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ItemProxy&lt;/code&gt; sends it to the Stargate coordinator via &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StargateBridgeClient&lt;/code&gt; which is essentially a gRPC client. The Stargate coordinator then talks to Cassandra nodes and returns the results back.&lt;/p&gt;

&lt;p&gt;Note that some requests are straightforward and only need one round-trip between Proxy — Stargate Coordinator — Cassandra cluster. Other requests are more complicated and may need multiple roundtrips. In the PutItem example shown in the sequence diagram, three round trips, at most, are needed. How come we need three round trips for a single write operation? That’s due to the schema difference between Cassandra and DynamoDB. Remember that in the beginning, we said DynamoDB is schemaless while Cassandra is not? That means you could insert an item to DynamoDB with new columns without pre-defining the schema (actually you cannot define a schema in DynamoDB), while you couldn’t do the same for Cassandra.&lt;/p&gt;

&lt;p&gt;In Cassandra, if a write operation contains columns that are unknown, the request fails. Therefore, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ItemProxy&lt;/code&gt; needs to first check whether the schema needs to be updated and if so, it must update the schema first before actually persisting the data. This sounds very slow, isn’t it? Luckily, Stargate has a caching mechanism, and most of the time, the schema will be cached and the overhead is small unless new columns appear frequently. \&lt;/p&gt;

&lt;p&gt;Now that you understand our motivation and the basic design for our service, stay tuned for our next blog in which I will talk about some interesting challenges we encountered and how we solved them.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Special thanks to all the members of the Stargate community who supported this effort including Prabhat Jha, Sebastian Estevez, Tatu Saloranta, and Jeff Carpenter.&lt;/em&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">To fulfill my capstone project requirement for the Carnegie Mellon University (CMU) Master of Computational Data Science (MCDS) program, I and two of my classmates, Ziyan Zhang and Xiang Yue, collaborated with DataStax to develop a new module in the Stargate system to bring Amazon DynamoDB compatibility to Apache Cassandra.Ⓡ I will introduce our journey in two blog posts. Here in Part 1, I will provide some background on the project and describe the overall design of our system. In Part 2, I will discuss some interesting challenges we encountered and how we solved them.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://stargate.io/assets/images/default-stargate.png" /><media:content medium="image" url="https://stargate.io/assets/images/default-stargate.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Stargate gRPC: The Better Way to CQL</title><link href="https://stargate.io/2022/01/15/stargate-grpc-the-better-way-to-cql.html" rel="alternate" type="text/html" title="Stargate gRPC: The Better Way to CQL" /><published>2022-01-15T06:00:00+00:00</published><updated>2022-01-15T06:00:00+00:00</updated><id>https://stargate.io/2022/01/15/stargate-grpc-the-better-way-to-cql</id><content type="html" xml:base="https://stargate.io/2022/01/15/stargate-grpc-the-better-way-to-cql.html">&lt;h1 id=&quot;stargate-grpc-the-better-way-to-cql&quot;&gt;&lt;strong&gt;Stargate gRPC: The Better Way to CQL&lt;/strong&gt;&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/data-cloud.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Stargate’s new gRPC API is so much more than just a feature release — it’s your official welcome to the “no drivers” future of Apache Cassandra.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Recently, we &lt;a href=&quot;https://stargate.io/2021/11/29/native-driver-alternatives-using-stargate-grpc-api-in-java&quot;&gt;released gRPC as the newest API&lt;/a&gt; supported by &lt;a href=&quot;https://stargate.io/&quot;&gt;Stargate&lt;/a&gt;, our API data gateway. On the surface, it would seem like the API doesn’t do very much; it receives CQL queries via the gRPC protocol, then passes those to &lt;a href=&quot;https://cassandra.apache.org/_/index.html&quot;&gt;Apache Cassandra®&lt;/a&gt; and returns the results. Sounds like a pretty modest feature release, right?&lt;/p&gt;

&lt;p&gt;In reality, what the Stargate team has delivered is groundbreaking. Not quite a native driver and not quite a simple HTTP-based API, Stargate’s gRPC implementation represents a fundamentally new approach for applications interacting with Cassandra — an approach that’s more cloud native than any driver, and more performant than any simple HTTP-based API.&lt;/p&gt;

&lt;p&gt;So let me tell you why this approach is so important, and why this is such a revolutionary solution for a common developer problem.&lt;/p&gt;

&lt;h2 id=&quot;native-drivers-are-not-cloud-friendly&quot;&gt;Native drivers are not cloud friendly&lt;/h2&gt;

&lt;p&gt;Functionality inside a native driver can be divided into two parts:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;The query engine.&lt;/strong&gt; This issues requests in a particular query language for a particular database, and receives responses to those requests that can then be used in application code. In our case, the query language is CQL, and the database is Cassandra.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Operational management.&lt;/strong&gt; This includes tasks like connection pooling, TLS, authentication, load balancing, retry policies, write coalescing, compression, health checks, etc.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You’ll notice that most of those operational tasks are abstracted away from applications in cloud environments, and simply handled automatically on behalf of the application. For example, load balancing, health checks, and TLS termination are intrinsic to most cloud environments; even retries can be configured within the environment.&lt;/p&gt;

&lt;p&gt;Put another way: in a well-designed microservices environment, network management tasks should live inside a service boundary and execute within an SLA defined in a service contract. There should be no need, and it would be a violation of microservices principles for an application to want to reach across that boundary and directly manipulate those operational tasks.&lt;/p&gt;

&lt;p&gt;And yet, this is exactly what native drivers do.&lt;/p&gt;

&lt;p&gt;This is not a mere architectural nicety. Building native drivers into an otherwise cloud-native, microservice-oriented application has real and negative consequences. Let’s dig a little deeper into why.&lt;/p&gt;

&lt;p&gt;Native protocol drivers are expensive to maintain and require reimplementing the same complex functionality for different platforms (like Java, Go, Node, Rust). All that operational management forces developers to extend their skill set from application development in their preferred language to areas of systems operation, thus steepening the learning curve for native drivers.&lt;/p&gt;

&lt;p&gt;More significantly, this co-mingling of concerns opens up a new vector that could trigger the need for a driver update. A configuration change in the network environment, for example, could require an update to the way every driver handles load balancing or connection pooling. Now your organization has to stop every application instance using that driver, apply the change within the driver, and restart all those application instances. Depending on the nature of the driver change, some changes in the rest of the application may also be required.&lt;/p&gt;

&lt;p&gt;They also inject surprising brittleness into applications because of the network management overhead required, making it more likely that drivers, and therefore applications that use them, must be updated.&lt;/p&gt;

&lt;p&gt;In sum, native drivers are:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Complex and present a steep learning curve&lt;/li&gt;
  &lt;li&gt;Hard to update and maintain&lt;/li&gt;
  &lt;li&gt;Speed bumps for developer velocity&lt;/li&gt;
  &lt;li&gt;A threat to application resilience&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So we can safely say that native drivers are fast, which makes it easy to overemphasize raw performance, but the overall picture of performance and resilience is much more complicated.&lt;/p&gt;

&lt;h2 id=&quot;http-based-apis-are-a-performance-trade-off&quot;&gt;HTTP-based APIs are a performance trade-off&lt;/h2&gt;

&lt;p&gt;The modern approach to application development is, in part, a rebellion against the burden of native drivers. Today’s application developers, particularly front end developers, are expected to interact with data through an HTTP-based API and rely on JSON as the primary method of structuring data.&lt;/p&gt;

&lt;p&gt;We fully support this API-based approach on Stargate. This has several advantages:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Language agnosticism.&lt;/strong&gt; Applications can be written in any language that can talk to an HTTP endpoint.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Separation of concerns&lt;/strong&gt; between application environment and infrastructure environment. Precisely as should happen in a cloud-native context, all of the network management and operational overhead lives behind the API. Changes and updates there stay contained within that service boundary, removing this as an area of concern for application logic.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Resilience.&lt;/strong&gt; The statelessness of HTTP constrains application design to avoid reliance on durable network connections, meaning applications designed in this manner are more resilient against the vagaries of network behavior.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Unsurprisingly, HTTP-based APIs have become the backbone of microservice applications for a cloud-native environment. But these benefits are not free. HTTP-based APIs are a slower way to query a database, for two reasons:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Networking&lt;/strong&gt; -  Native drivers talk “closer to the wire,” which significantly improves performance. The Java driver for CQL, for example, operates at Layer 5, whereas HTTP operates at Layer 7.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Data transformation&lt;/strong&gt; - Databases don’t store JSON natively (even MongoDB relies on the WiredTiger storage engine when you drill down far enough). So some transformation has to happen to turn a JSON-oriented query into a native database query (CQL, in the case of Cassandra). The compute overhead of performing this transformation further slows performance.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;And now, we have a dilemma. On one hand, HTTP-based APIs offer simplicity and language agnosticism that accelerates developer velocity, while also offering a separation of concerns between application and infrastructure that improves application resilience. To put it simply, HTTP-based APIs are good cloud citizens, presenting and abiding by clear service boundaries.&lt;/p&gt;

&lt;p&gt;On the other hand, while native drivers are a burden to developers and co-mingled concerns between development and operations negatively impact resilience, native drivers are just flat out more performant than HTTP-based APIs.&lt;/p&gt;

&lt;p&gt;So, what to do?&lt;/p&gt;

&lt;h2 id=&quot;decomposing-the-driver&quot;&gt;Decomposing the driver&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://stargate.io/&quot;&gt;Stargate&lt;/a&gt; supports native driver calls, offering a CQL API through which to talk to Cassandra. This is essentially just a transparent proxy, and so CQL calls via Stargate remain highly performant. Let’s look at a simple architecture diagram of this part of Stargate. (See Figure 1.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/grpc-1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Figure 1: Simple Architecture of Native Driver and Stargate.&lt;/p&gt;

&lt;p&gt;The fundamental problem is the co-mingling of concerns. Some of what lives inside the native driver should, in a cloud-native context, live behind an API and thus inside the API’s service boundary. So what if we looked at it this way instead? (See Figure 2.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/grpc-2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Figure 2: Decomposing the driver.&lt;/p&gt;

&lt;p&gt;The real challenge is how to move that box that says “Network Management Tasks” across the service boundary into Stargate and behind an API. We’ll also have to do it in a way that honors the language agnosticism of APIs. Without that agnosticism, we have to maintain a different “box” of network management tasks for each language, even though those tasks are essentially the same across languages. We’d lighten the driver but make Stargate harder to maintain, and a good bit less cloud friendly.&lt;/p&gt;

&lt;h2 id=&quot;enter-grpc&quot;&gt;Enter gRPC&lt;/h2&gt;

&lt;p&gt;In 2008, Google developed, open-sourced and released &lt;a href=&quot;https://developers.google.com/protocol-buffers&quot;&gt;Protocol Buffers&lt;/a&gt; — a language-neutral mechanism for serializing structured data. In 2015, Google released &lt;a href=&quot;https://grpc.io/&quot;&gt;gRPC&lt;/a&gt; (also open source) to incorporate Protocol Buffers into work to modernize Remote Procedure Call (RPC).&lt;/p&gt;

&lt;p&gt;gRPC has a couple of important performance characteristics. One is the improved data serialization, making data transit over the network much more efficient. The other is the use of HTTP/2, which enables bidirectional communication. As a result, there are four call types supported in gRPC:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Unary calls&lt;/li&gt;
  &lt;li&gt;Client side streaming calls&lt;/li&gt;
  &lt;li&gt;Server side streaming calls&lt;/li&gt;
  &lt;li&gt;Bidirectional calls, which are a composite of client side and server side streaming&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Put all this together and you have a mechanism that is fast — &lt;em&gt;very&lt;/em&gt; fast when compared to other HTTP-based APIs. gRPC message transmission can be &lt;a href=&quot;https://blog.dreamfactory.com/grpc-vs-rest-how-does-grpc-compare-with-traditional-rest-apis/&quot;&gt;7x to 10x faster&lt;/a&gt; than traditional REST APIs. In other words, a solution based on gRPC could offer performance comparable to native drivers.&lt;/p&gt;

&lt;h2 id=&quot;stargate-grpc&quot;&gt;Stargate gRPC&lt;/h2&gt;

&lt;p&gt;When you pull all of the network management tasks out of a driver, what you’re left with is a thin client library containing little more than the query engine. In our case, these CQL queries transit to a Stargate API endpoint via gRPC. (See Figure 3.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/grpc-3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Figure 3: Stargate’s gRPC Implementation.&lt;/p&gt;

&lt;p&gt;Behind that endpoint is what amounts to a CQL driver written in gRPC. In other words, it receives CQL calls on the API endpoint via gRPC, and then makes direct CQL calls to Cassandra. No data transformation is required, because we’re using CQL end to end.&lt;/p&gt;

&lt;p&gt;These client libraries are dramatically easier to write and maintain. Our original intent was to launch with client libraries for Java and for Go, since these are our two most requested languages. As it happened, adding new languages was so easy that we also included client libraries for Node.js and Rust.&lt;/p&gt;

&lt;p&gt;These four — and perhaps more languages in the future -— represent a fully DataStax-supported way to make CQL calls from your application. We’ll continue to support our existing native drivers, and in those languages the gRPC client libraries represent an additional, supported alternative. For languages like Go where DataStax does not have a supported native driver, the supported gRPC client library is now a great way to go.&lt;/p&gt;

&lt;h2 id=&quot;do-more-with-stargate-grpc&quot;&gt;Do more with Stargate gRPC&lt;/h2&gt;

&lt;p&gt;If your favorite language is not on our list, extending to a new language is not hard. From a protobuf file you get a skeleton of the CQL calls you need to make in your chosen language, and none of the operational overhead is required. You get that out of the box with gRPC, and it lives inside of Stargate where it belongs in a proper cloud-native context.&lt;/p&gt;

&lt;p&gt;Thanks to bidirectionality and efficient data serialization, you’ll now get performance on par with native drivers combined with the simplicity of a thin client library, all within a context that plays nicely with the rest of your microservices.&lt;/p&gt;

&lt;p&gt;To learn more, head over to &lt;a href=&quot;https://github.com/stargate&quot;&gt;Stargate’s Github&lt;/a&gt;. You can also find source code and examples on &lt;a href=&quot;https://stargate.io/docs/stargate/1.0/developers-guide/gRPC-using.html&quot;&gt;using Stargate gRPC API clients&lt;/a&gt;:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/stargate/stargate-grpc-java-client&quot;&gt;Java client&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/stargate/stargate-grpc-go-client&quot;&gt;Go client&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/stargate/stargate-grpc-node-client&quot;&gt;Node.js client&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/stargate/stargate-grpc-rust-client&quot;&gt;Rust client&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;And, lastly, welcome to the “No Drivers” future of Apache Cassandra.&lt;/p&gt;

&lt;h2 id=&quot;resources&quot;&gt;&lt;strong&gt;Resources&lt;/strong&gt;&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/stargate&quot;&gt;Stargate - GitHub&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://stargate.io/docs/stargate/1.0/developers-guide/gRPC-using.html&quot;&gt;Using Stargate gRPC API clients&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://stargate.io/2021/11/29/native-driver-alternatives-using-stargate-grpc-api-in-java&quot;&gt;Native Driver Alternatives Using Stargate gRPC API in Java&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><summary type="html">Stargate gRPC: The Better Way to CQL</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://stargate.io/assets/images/default-stargate.png" /><media:content medium="image" url="https://stargate.io/assets/images/default-stargate.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Stargate v2 Update: Reaching the First Milestone</title><link href="https://stargate.io/2022/01/06/reaching-the-first-milestone.html" rel="alternate" type="text/html" title="Stargate v2 Update: Reaching the First Milestone" /><published>2022-01-06T06:00:00+00:00</published><updated>2022-01-06T06:00:00+00:00</updated><id>https://stargate.io/2022/01/06/reaching-the-first-milestone</id><content type="html" xml:base="https://stargate.io/2022/01/06/reaching-the-first-milestone.html">&lt;h1 id=&quot;stargate-v2-update-reaching-the-first-milestone&quot;&gt;Stargate v2 Update: Reaching the First Milestone&lt;/h1&gt;

&lt;p&gt;Back in November, we shared the goals of the &lt;a href=&quot;https://stargate.io/2021/11/02/announcing-stargate-v2.html&quot;&gt;Stargate v2 release&lt;/a&gt; and our &lt;a href=&quot;https://stargate.io/2021/11/02/introducing-the-design-for-stargate-v2.html&quot;&gt;proposed design approach&lt;/a&gt;, and now it’s time for a progress check. To kick off 2022, the Stargate team is excited to provide an update on our first milestone in the continued development of Stargate v2.&lt;/p&gt;

&lt;p&gt;For this first milestone, we adopted a “steel thread” approach – our goal was to begin &lt;a href=&quot;https://stargate.io/2021/11/02/announcing-stargate-v2.html&quot;&gt;breaking up the monolith&lt;/a&gt; by factoring a single API service out of the Stargate coordinator node – the REST API service. While the original v2 design referenced above includes the introduction of a new gRPC “Bridge” component, we elected to use the new gRPC API that was released in November 2021 as a placeholder for the Bridge in this first milestone, and defer starting work on the Bridge to the next milestone. This enabled us to work more quickly and focus on separating out the new service from the Coordinator Node. The result of what we built is shown in Figure 1 below:&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/assets/images/steel-thread-image.png&quot; alt=&quot;Figure 1: Summary of Stargate v2 Milestone 1 implementation.&quot; /&gt;
  &lt;figcaption style=&quot;text-align: center;&quot;&gt;Figure 1: Summary of Stargate v2 Milestone 1 implementation.&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;You can find our work on the new standalone REST API service on the &lt;a href=&quot;https://github.com/stargate/stargate/tree/v2.0.0&quot;&gt;v2.0.0 branch&lt;/a&gt; in the &lt;a href=&quot;https://github.com/stargate/stargate/tree/v2.0.0/sgv2-restapi&quot;&gt;sgv2-restapi module&lt;/a&gt;. While the new REST API service is not production-ready, at the time of writing it is passing over 90% of the integration tests for the REST v2 endpoints. In fact, the easiest way to see the new endpoint in action is to check out the v2.0.0 branch and run the integration test suite as described in the project &lt;a href=&quot;https://github.com/stargate/stargate/blob/v2.0.0/README.md&quot;&gt;README&lt;/a&gt;. We’re also working on ”Dockerizing” this configuration as well.&lt;/p&gt;

&lt;p&gt;We had some interesting learnings and design discussions that came up along the way. We captured a bunch of them in our retrospective, and then did some affinity mapping to identify common themes. In the sections below, we’ll cover some of the key points that emerged from this exercise.&lt;/p&gt;

&lt;h2 id=&quot;open-discussions&quot;&gt;Open discussions&lt;/h2&gt;

&lt;p&gt;One of our main goals for Stargate v2 has been to make it easier for new contributors to get involved. To help move things in that direction, we’ve started documenting design discussions and proposals via &lt;a href=&quot;https://github.com/stargate/stargate/discussions&quot;&gt;GitHub discussions&lt;/a&gt; instead of private Google docs so that the community can benefit and participate. In fact, we’ll link to some of those discussions in the sections below.&lt;/p&gt;

&lt;h2 id=&quot;rest-api-observations&quot;&gt;REST API observations&lt;/h2&gt;

&lt;p&gt;As we were planning Stargate v2, we decided to focus on the architectural refactoring over making improvements to the existing APIs, in order to move quickly and in order to preserve backward compatibility. However, as we worked to make sure the new REST API service worked the same as the existing Stargate v1 REST endpoint, we actually found a few defects and improvements, which we have been documenting in a &lt;a href=&quot;https://github.com/stargate/stargate/discussions/1501&quot;&gt;GitHub discussion&lt;/a&gt; and making equivalent fixes for both Stargate v1 and v2.&lt;/p&gt;

&lt;p&gt;As noted above, we have completed the implementation of the majority of the “REST v2” endpoints (e.g. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/v2/keyspaces…&lt;/code&gt;) in the new REST API Service. We did not prioritize implementation of the “REST v1” endpoints (e.g. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/v1/keyspaces/…&lt;/code&gt;) and are investigating how widely used the v1 endpoints are in order to determine the level of interest in bringing those endpoints forward into Stargate v2. Please reach out on the &lt;a href=&quot;https://github.com/stargate/stargate/discussions/1528&quot;&gt;GitHub discussion&lt;/a&gt; if you have feedback on this.&lt;/p&gt;

&lt;h2 id=&quot;talking-to-coordinator-nodes-via-grpc&quot;&gt;Talking to coordinator nodes via gRPC&lt;/h2&gt;

&lt;p&gt;We were able to move quickly in implementing the new REST API service by using the new gRPC API exposed by the Stargate coordinator nodes. We’ve started to refer to the style of this interface as “CQL over gRPC” because the operations on the gRPC endpoint work in terms of providing CQL query strings and an array of parameters you wish to bind to the query string. We ended up creating a standalone query builder similar to the one available in the DataStax Java Driver in order to construct CQL strings that the standalone REST service could pass to the gRPC API. This work was not part of our original plan, but we hope it will make implementing subsequent services go more quickly.&lt;/p&gt;

&lt;h2 id=&quot;packaging-and-releasing-for-docker-and-kubernetes&quot;&gt;Packaging and releasing for Docker and Kubernetes&lt;/h2&gt;

&lt;p&gt;As mentioned above, we have an integration test configuration that launches the new REST API service alongside Stargate coordinator and Apache Cassandra&lt;strong&gt;®&lt;/strong&gt; nodes. We’re working on updated release processes so that we can have tagged releases for v2, associated Docker images, and example configurations for Docker Compose and Kubernetes.&lt;/p&gt;

&lt;p&gt;Since one of the Stargate v2 goals is to be more Docker/Kubernetes friendly, we’re also working on building Docker images as part of our regular Maven builds so we can make use of the images in local development for unit and integration testing. We’re looking at &lt;a href=&quot;https://github.com/GoogleContainerTools/jib&quot;&gt;Google’s Jib&lt;/a&gt; as a possible option to replace our current process, which uses a separate &lt;a href=&quot;https://github.com/stargate/docker-images&quot;&gt;docker-images&lt;/a&gt; repo to build Docker images only after a release.&lt;/p&gt;

&lt;h2 id=&quot;whats-next-for-milestone-2&quot;&gt;What’s next for Milestone 2?&lt;/h2&gt;

&lt;p&gt;Now that we’ve mostly completed breaking our first API service out of the monolith, we’re working on setting up performance testing, reviewing the architecture, and getting ready to factor the GraphQL and Document APIs into their own services.&lt;/p&gt;

&lt;p&gt;We’d love to hear your inputs about the new architecture and the progress that is being made on the new implementation, so feel free to jump into the conversation on &lt;a href=&quot;https://discord.gg/HHtMAvjaZB&quot;&gt;Discord&lt;/a&gt; with questions, or comment on our &lt;a href=&quot;https://github.com/stargate/stargate/discussions?discussions_q=label:stargate-v2&quot;&gt;design discussions on GitHub&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Special thanks to Tatu Saloranta, Olivier Michallat, Doug Wettlaufer and Mark Stone for their contributions to the Stargate v2 effort and this post.&lt;/em&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">Stargate v2 Update: Reaching the First Milestone</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://stargate.io/assets/images/default-stargate.png" /><media:content medium="image" url="https://stargate.io/assets/images/default-stargate.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Announcing Github branch renaming change</title><link href="https://stargate.io/2021/12/14/announce-github-naming-change.html" rel="alternate" type="text/html" title="Announcing Github branch renaming change" /><published>2021-12-14T06:00:00+00:00</published><updated>2021-12-14T06:00:00+00:00</updated><id>https://stargate.io/2021/12/14/announce-github-naming-change</id><content type="html" xml:base="https://stargate.io/2021/12/14/announce-github-naming-change.html">&lt;p&gt;Starting in October 2020, all new source code repositories created on GitHub have a primary branch named &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main&lt;/code&gt; instead of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;master&lt;/code&gt; as part of the company’s effort to remove unnecessary references to slavery and replace them with more inclusive terms. This “fix forward first” approach is the first step in making systemic changes to the naming conventions.&lt;/p&gt;

&lt;p&gt;Github will also gradually rename their own internal repositories over time. This reflects the difficulty that Github and other organizations face – it’s hard to rename something that is in active use.&lt;/p&gt;

&lt;p&gt;Hard, but not impossible, and it’s the right thing to do. We at the Stargate project are following suit. We’ll use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main&lt;/code&gt; as the name of our primary branch going forward, and we are actively renaming existing primary branches to be named &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main&lt;/code&gt;. The Docs repo is the first to get renamed. Others will follow. We can’t let inertia be an impediment. We want our work on Stargate to be open, transparent, and inclusive. This is a necessary step to align with the virtue of inclusivity.&lt;/p&gt;</content><author><name></name></author><summary type="html">Starting in October 2020, all new source code repositories created on GitHub have a primary branch named main instead of master as part of the company’s effort to remove unnecessary references to slavery and replace them with more inclusive terms. This “fix forward first” approach is the first step in making systemic changes to the naming conventions.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://stargate.io/assets/images/default-stargate.png" /><media:content medium="image" url="https://stargate.io/assets/images/default-stargate.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Native Driver Alternatives Using Stargate gRPC API in Java</title><link href="https://stargate.io/2021/11/29/native-driver-alternatives-using-stargate-grpc-api-in-java.html" rel="alternate" type="text/html" title="Native Driver Alternatives Using Stargate gRPC API in Java" /><published>2021-11-29T06:00:00+00:00</published><updated>2021-11-29T06:00:00+00:00</updated><id>https://stargate.io/2021/11/29/native-driver-alternatives-using-stargate-grpc-api-in-java</id><content type="html" xml:base="https://stargate.io/2021/11/29/native-driver-alternatives-using-stargate-grpc-api-in-java.html">&lt;p&gt;Developers should be able to build highly scalable apps even when they call multilingual and multi-cloud microservices. That’s why the Stargate team recently made a new API generally available to help developers build applications with their preferred language.&lt;/p&gt;

&lt;p&gt;The new API is called &lt;a href=&quot;https://dtsx.io/2Z2nCfU&quot;&gt;gRPC Remote Procedure Call&lt;/a&gt; (gRPC), and we built it on the framework created by Google. In this post, we’ll show you how easy it is to start using this API from the Java ecosystem. We’ll also explain the basic methods exposed to the clients that allow us to interact with the gRPC API.&lt;/p&gt;

&lt;p&gt;The setup is simple. The generated code based on protobuf files (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;query.proto&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stargate.proto&lt;/code&gt;) is shipped with the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;grpc-proto&lt;/code&gt; dependency. In your client application, you only need to add two dependencies, the client and a functional channel service provider. In this example we picked netty:&lt;/p&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;dependencies&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;io.stargate.grpc&lt;span class=&quot;nt&quot;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;grpc-proto&lt;span class=&quot;nt&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;version&amp;gt;&lt;/span&gt;1.0.40&lt;span class=&quot;nt&quot;&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
         &lt;span class=&quot;nt&quot;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;io.grpc&lt;span class=&quot;nt&quot;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
         &lt;span class=&quot;nt&quot;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;grpc-netty-shaded&lt;span class=&quot;nt&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
         &lt;span class=&quot;nt&quot;&gt;&amp;lt;version&amp;gt;&lt;/span&gt;1.40.1&lt;span class=&quot;nt&quot;&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/dependencies&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;If you don’t add the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;grpc-netty-shaded&lt;/code&gt;, you’ll get the following error:&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;No functional channel service provider found. Try adding a dependency on the grpc-okhttp, grpc-netty, or grpc-netty-shaded artifact.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Once we have all the needed dependencies we should be able to use the Stargate gRPC-stub API.&lt;/p&gt;

&lt;p&gt;After this step, you should have &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StargateGrpc&lt;/code&gt; available on your classpath from the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;grpc-proto&lt;/code&gt; dependency. It contains the logic for interacting with Stargate gRPC API.&lt;/p&gt;

&lt;h2 id=&quot;putting-the-stargate-grpc-api-to-use&quot;&gt;Putting the Stargate gRPC API to use&lt;/h2&gt;

&lt;p&gt;Once we have the generated code with the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StargateGrpc&lt;/code&gt; class shipped within &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;grpc-proto&lt;/code&gt; dependency, we’re ready to create the client.&lt;/p&gt;

&lt;p&gt;Before delving into the code, we need to generate the auth token that will be used to perform authorization. Please visit the &lt;a href=&quot;https://dtsx.io/3csSw47&quot;&gt;Stargate Authz documentation&lt;/a&gt; for a guide on this. Here’s some code that will work for our needs:&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl &lt;span class=&quot;nt&quot;&gt;-L&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-X&lt;/span&gt; POST &lt;span class=&quot;s1&quot;&gt;'localhost:8081/v1/auth'&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;-H&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'Content-Type: application/json'&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;--data-raw&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'{
    &quot;username&quot;: &quot;cassandra&quot;,
    &quot;password&quot;: &quot;cassandra&quot;
}'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;In this snippet, we’re assuming that Stargate is running on the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;localhost:8081&lt;/code&gt;. Once we have that, we can connect to the gRPC API. First, we need to generate the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Channel&lt;/code&gt; that is used to perform the connection:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ManagedChannel&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;createChannel&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;host&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ManagedChannelBuilder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;forAddress&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;host&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;usePlaintext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;build&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Please note that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;usePlaintext()&lt;/code&gt; should only be used for development and testing. When used in a production environment it should use a load balancer that terminates transport layer security (TLS). For local development of Stargate, it will be:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;ManagedChannel&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;channel&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;createChannel&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;localhost&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8090&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Next, we can generate the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;StargateGrpc&lt;/code&gt; stub. There are two ways of interacting with the gRPC API. The first one is synchronous (blocking):&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;io.stargate.grpc.StargateBearerToken&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;nc&quot;&gt;StargateGrpc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;StargateBlockingStub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;blockingStub&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;StargateGrpc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;newBlockingStub&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;channel&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
     &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;withCallCredentials&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;StargateBearerToken&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;token-value&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The second way of interacting is asynchronous (non-blocking):&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;StargateGrpc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;StargateStub&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;StargateGrpc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;newStub&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;channel&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;withCallCredentials&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;StargateBearerToken&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;token-value&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We will focus on the blocking approach in this example since it is simpler to illustrate. Please be aware that for your use case you might need to use the second approach.&lt;/p&gt;

&lt;p&gt;We need to set up the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CallCredentials&lt;/code&gt;, using the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;token-value&lt;/code&gt; generated in the previous step. We will assume that all queries are executed within the existing keyspace &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ks&lt;/code&gt; and table &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;test&lt;/code&gt;. The table definition is as follows:&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IF&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;EXISTS&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;test&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;PRIMARY&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;KEY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The Stargate gRPC API provides a way to execute two types of queries: Standard CQL queries and batch queries containing N CQL queries.&lt;/p&gt;

&lt;h2 id=&quot;build-and-execute-a-standard-query-with-the-grpc-api&quot;&gt;Build and execute a standard query with the gRPC API&lt;/h2&gt;

&lt;p&gt;When we want to run a standard query we can start by inserting a record using the gRPC stub:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;io.stargate.proto.QueryOuterClass.Response&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;io.stargate.proto.QueryOuterClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;nc&quot;&gt;Response&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;response&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;blockingStub&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;executeQuery&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;QueryOuterClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;Query&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;newBuilder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setCql&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;INSERT INTO ks.test (k, v) VALUES ('a', 1)&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;build&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This will build and execute a single query. Next, we can retrieve the inserted record(s):&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;Response&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;response&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stub&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;executeQuery&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;QueryOuterClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;Query&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;newBuilder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setCql&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;SELECT k, v FROM ks.test&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;build&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;If we print out the result set, it will have the following structure:&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;result_set &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  data &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    type_url: &lt;span class=&quot;s2&quot;&gt;&quot;type.googleapis.com/stargate.ResultSet&quot;&lt;/span&gt;
    value: &lt;span class=&quot;s2&quot;&gt;&quot;some_binary_data&quot;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The value contains the binary data, that we can deserialize. First, we need to unwrap the result set:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;ResultSet&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rs&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;response&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getResultSet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;rs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getRows&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getValues&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getString&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// it will return value for k = &quot;a&quot;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;rs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getRows&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getValues&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getInt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// it will return value for v = 1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We can get all rows with the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getRowsList()&lt;/code&gt; method and iterate over the result or get the specific row using its index and pass it to the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getRows(int index)&lt;/code&gt; method. We picked the latter approach in the example above.&lt;/p&gt;

&lt;p&gt;Our retrieval query (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SELECT k, v FROM ks.test&lt;/code&gt;) stated explicitly which columns should be retrieved. Because of that, we can safely get the values using their positions via the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getValues()&lt;/code&gt; method.&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getString()&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getInt()&lt;/code&gt; perform deserialization of data. These methods were used because we knew the underlying type of the corresponding columns. The API provides utility methods for deserialization for more types as well. For the full list of available types, see &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;value&lt;/code&gt; section in the &lt;a href=&quot;https://dtsx.io/3nxrgYI&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;query.proto&lt;/code&gt;&lt;/a&gt; file. If you want to iterate over all results, you can with this snippet:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;QueryOuterClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;Row&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;row:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getRowsList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()){&lt;/span&gt;
      &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;row&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getValuesList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This will allow you to operate on a single row. When you execute it, you’ll get the following:&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;string: &lt;span class=&quot;s2&quot;&gt;&quot;a&quot;&lt;/span&gt;
, int: 1 &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;run-batch-queries-with-stargate-grpc-api&quot;&gt;Run Batch queries with Stargate gRPC API&lt;/h2&gt;

&lt;p&gt;In case we want to execute N queries, we can use the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;executeBatch&lt;/code&gt; method:&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;QueryOuterClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;Response&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;response&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;blockingStub&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;executeBatch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;QueryOuterClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;Batch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;newBuilder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;               
        &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;addQueries&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
            &lt;span class=&quot;nc&quot;&gt;QueryOuterClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;BatchQuery&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;newBuilder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setCql&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;INSERT INTO ks.test (k, v) VALUES ('a', 1)&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;build&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
         &lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;          
         &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;addQueries&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt; 
             &lt;span class=&quot;nc&quot;&gt;QueryOuterClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;BatchQuery&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;newBuilder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
                 &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setCql&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;INSERT INTO ks.test (k, v) VALUES ('b', 2)&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;build&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
                 &lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                 &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;build&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This takes the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Batch&lt;/code&gt; as an argument. A &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Batch&lt;/code&gt; can contain N queries of type &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;INSERT&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UPDATE&lt;/code&gt;, or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DELETE&lt;/code&gt;. We are adding two queries via the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;addQueries&lt;/code&gt; method. You can learn more about handling the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Batch&lt;/code&gt; request in the &lt;a href=&quot;https://dtsx.io/3cs7doc&quot;&gt;Batch Documentation&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Now you know how to integrate the gRPC client via &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;blockingStub&lt;/code&gt;. If you want to dive deeper into it take a look at the &lt;a href=&quot;https://dtsx.io/2Z2nCfU&quot;&gt;Java Client documentation on gRPC&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;resources&quot;&gt;Resources&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://dtsx.io/3qTlaUL&quot;&gt;Join the Stargate community&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://dtsx.io/2Z2nCfU&quot;&gt;Using Stargate gRPC API clients for Rust, Go and Node.js&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><summary type="html">Developers should be able to build highly scalable apps even when they call multilingual and multi-cloud microservices. That’s why the Stargate team recently made a new API generally available to help developers build applications with their preferred language.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://stargate.io/assets/images/default-stargate.png" /><media:content medium="image" url="https://stargate.io/assets/images/default-stargate.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry></feed>